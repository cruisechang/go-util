# errors

provides an easy way to annotate errors without losing the orginal error context.

The exported `New` and `Errorf` functions are designed to replace the
`errors.New` and `fmt.Errorf` functions respectively. The same underlying
error is there, but the package also records the location at which the error
was created.

A primary use case for this library is to add extra context any time an
error is returned from a function.


	    if err := SomeFunc(); err != nil {
		    return err
		}

This instead becomes:


	    if err := SomeFunc(); err != nil {
		    return errors.Trace(err)
		}

which just records the file and line number of the Trace call, or


	    if err := SomeFunc(); err != nil {
		    return errors.Annotate(err, "more context")
		}

which also adds an annotation to the error.

When you want to check to see if an error is of a particular type, a helper
function is normally exported by the package that returned the error, like the
`os` package does.  The underlying cause of the error is available using the
`Cause` function.


	os.IsNotExist(errors.Cause(err))

The result of the `Error()` call on an annotated error is the annotations joined
with colons, then the result of the `Error()` method for the underlying error
that was the cause.


	err := errors.Errorf("original")
	err = errors.Annotatef(err, "context")
	err = errors.Annotatef(err, "more context")
	err.Error() -> "more context: context: original"

Obviously recording the file, line and functions is not very useful if you
cannot get them back out again.


	errors.ErrorStack(err)

will return something like:


	first error
	github.com/juju/errors/annotation_test.go:193:
	github.com/juju/errors/annotation_test.go:194: annotation
	github.com/juju/errors/annotation_test.go:195:
	github.com/juju/errors/annotation_test.go:196: more context
	github.com/juju/errors/annotation_test.go:197:

The first error was generated by an external system, so there was no location
associated. The second, fourth, and last lines were generated with Trace calls,
and the other two through Annotate.


## func Annotate
``` go
func Annotate(other error, message string) error
```
Annotate is used to add extra context to an existing error. The location of
the Annotate call is recorded with the annotations. The file, line and
function are also recorded.

For example:


	if err := SomeFunc(); err != nil {
	    return errors.Annotate(err, "failed to frombulate")
	}


## func Annotatef
``` go
func Annotatef(other error, format string, args ...interface{}) error
```
Annotatef is used to add extra context to an existing error. The location of
the Annotate call is recorded with the annotations. The file, line and
function are also recorded.

For example:


	if err := SomeFunc(); err != nil {
	    return errors.Annotatef(err, "failed to frombulate the %s", arg)
	}


## func Cause
``` go
func Cause(err error) error
```
Cause returns the cause of the given error.  This will be either the
original error, or the result of a Wrap or Mask call.

Cause is the usual way to diagnose errors that may have been wrapped by
the other errors functions.


## func Details
``` go
func Details(err error) string
```
Details returns information about the stack of errors wrapped by err, in
the format:


	[{filename:99: error one} {otherfile:55: cause of error one}]

This is a terse alternative to ErrorStack as it returns a single line.


## func ErrorStack
``` go
func ErrorStack(err error) string
```
ErrorStack returns a string representation of the annotated error. If the
error passed as the parameter is not an annotated error, the result is
simply the result of the Error() method on that error.

If the error is an annotated error, a multi-line string is returned where
each line represents one entry in the annotation stack. The full filename
from the call stack is used in the output.


	first error
	github.com/juju/errors/annotation_test.go:193:
	github.com/juju/errors/annotation_test.go:194: annotation
	github.com/juju/errors/annotation_test.go:195:
	github.com/juju/errors/annotation_test.go:196: more context
	github.com/juju/errors/annotation_test.go:197:


## func Errorf
``` go
func Errorf(format string, args ...interface{}) error
```
Errorf creates a new annotated error and records the location that the
error is created.  This should be a drop in replacement for fmt.Errorf.

For example:


	return errors.Errorf("validation failed: %s", message)


## func New
``` go
func New(message string) error
```
New is a drop in replacement for the standard libary errors module that records
the location that the error is created.

For example:


	return errors.New("validation failed")


## func Trace
``` go
func Trace(other error) error
```
Trace adds the location of the Trace call to the stack.  The Cause of the
resulting error is the same as the error parameter.  If the other error is
nil, the result will be nil.

For example:


	if err := SomeFunc(); err != nil {
	    return errors.Trace(err)
	}
